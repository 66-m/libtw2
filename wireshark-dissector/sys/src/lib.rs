#![allow(bad_style)]
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const ENC_BIG_ENDIAN: ::std::os::raw::c_uint = 0;
pub const ENC_NA: ::std::os::raw::c_uint = 0;
pub type guint8 = ::std::os::raw::c_uchar;
pub type guint16 = ::std::os::raw::c_ushort;
pub type guint32 = ::std::os::raw::c_uint;
pub type guint64 = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type time_t = __time_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type GHashTable = u8;
pub type GSList = [u64; 2usize];
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
/// A public opaque type representing one wmem allocation pool.
pub type wmem_allocator_t = u8;
extern "C" {

    /// Allocate the requested amount of memory in the given pool.
    ///
    /// @param allocator The allocator object to use to allocate the memory.
    /// @param size The amount of memory to allocate.
    /// @return A void pointer to the newly allocated memory.
    pub fn wmem_alloc(allocator: *mut wmem_allocator_t, size: usize)
        -> *mut ::std::os::raw::c_void;
}
pub type wmem_list_t = u8;
/// data structure to hold time values with nanosecond resolution
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nstime_t {
    pub secs: time_t,
    pub nsecs: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_nstime_t() {
    assert_eq!(
        ::std::mem::size_of::<nstime_t>(),
        16usize,
        concat!("Size of: ", stringify!(nstime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<nstime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(nstime_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).secs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(secs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nstime_t>())).nsecs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nstime_t),
            "::",
            stringify!(nsecs)
        )
    );
}
pub type tvbuff_t = u8;
extern "C" {
    pub fn tvb_new_child_real_data(
        parent: *mut tvbuff_t,
        data: *const guint8,
        length: guint,
        reported_length: gint,
    ) -> *mut tvbuff_t;
}
extern "C" {

    /// Similar to tvb_new_subset_length_caplen() but with backing_length and reported_length set
    /// to -1.  Can throw ReportedBoundsError.
    pub fn tvb_new_subset_remaining(backing: *mut tvbuff_t, backing_offset: gint) -> *mut tvbuff_t;
}
extern "C" {
    pub fn tvb_captured_length(tvb: *const tvbuff_t) -> guint;
}
extern "C" {

    /// Returns target for convenience. Does not suffer from possible
    /// expense of tvb_get_ptr(), since this routine is smart enough
    /// to copy data in chunks if the request range actually exists in
    /// different TVBUFF_REAL_DATA tvbuffs. This function assumes that the
    /// target memory is already allocated; it does not allocate or free the
    /// target memory.
    pub fn tvb_memcpy(
        tvb: *mut tvbuff_t,
        target: *mut ::std::os::raw::c_void,
        offset: gint,
        length: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wtap_pkthdr {
    _unused: [u8; 0],
}
pub type frame_data = [u64; 11usize];
pub type address = [u64; 3usize];
pub const PT_NONE: port_type = 0;
pub const PT_SCTP: port_type = 1;
pub const PT_TCP: port_type = 2;
pub const PT_UDP: port_type = 3;
pub const PT_DCCP: port_type = 4;
pub const PT_IPX: port_type = 5;
pub const PT_NCP: port_type = 6;
pub const PT_EXCHG: port_type = 7;
pub const PT_DDP: port_type = 8;
pub const PT_SBCCS: port_type = 9;
pub const PT_IDP: port_type = 10;
pub const PT_TIPC: port_type = 11;
pub const PT_USB: port_type = 12;
pub const PT_I2C: port_type = 13;
pub const PT_IBQP: port_type = 14;
pub const PT_BLUETOOTH: port_type = 15;
pub const PT_TDMOP: port_type = 16;
pub type port_type = u32;
pub const CT_NONE: circuit_type = 0;
pub const CT_DLCI: circuit_type = 1;
pub const CT_ISDN: circuit_type = 2;
pub const CT_X25: circuit_type = 3;
pub const CT_ISUP: circuit_type = 4;
pub const CT_IAX2: circuit_type = 5;
pub const CT_H223: circuit_type = 6;
pub const CT_BICC: circuit_type = 7;
pub const CT_DVBCI: circuit_type = 8;
pub const CT_ISO14443: circuit_type = 9;
pub type circuit_type = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info {
    /// < name of protocol currently being dissected
    pub current_proto: *const ::std::os::raw::c_char,
    /// < Column formatting information
    pub cinfo: *mut epan_column_info,
    /// < Presence flags for some items
    pub presence_flags: guint32,
    /// < Frame number
    pub num: guint32,
    /// < Packet absolute time stamp
    pub abs_ts: nstime_t,
    /// < Relative timestamp (yes, it can be negative)
    pub rel_ts: nstime_t,
    /// < Per-packet encapsulation/data-link type
    pub pkt_encap: gint,
    pub fd: *mut frame_data,
    pub pseudo_header: *mut wtap_pseudo_header,
    /// < Record metadata
    pub phdr: *mut wtap_pkthdr,
    /// < Frame data sources
    pub data_src: *mut GSList,
    /// < link-layer source address
    pub dl_src: address,
    /// < link-layer destination address
    pub dl_dst: address,
    /// < network-layer source address
    pub net_src: address,
    /// < network-layer destination address
    pub net_dst: address,
    /// < source address (net if present, DL otherwise )
    pub src: address,
    /// < destination address (net if present, DL otherwise )
    pub dst: address,
    /// < First encountered VLAN Id if pressent otherwise 0
    pub vlan_id: guint32,
    /// < type of circuit, for protocols with a VC identifier
    pub ctype: circuit_type,
    /// < circuit ID, for protocols with a VC identifier
    pub circuit_id: guint32,
    /// < reason why reassembly wasn't done, if any
    pub noreassembly_reason: *const ::std::os::raw::c_char,
    /// < TRUE if the protocol is only a fragment
    pub fragmented: gboolean,
    pub flags: _packet_info__bindgen_ty_1,
    /// < type of the following two port numbers
    pub ptype: port_type,
    /// < source port
    pub srcport: guint32,
    /// < destination port
    pub destport: guint32,
    /// < matched uint for calling subdissector from table
    pub match_uint: guint32,
    /// < matched string for calling subdissector from table
    pub match_string: *const ::std::os::raw::c_char,
    /// < >0 if this segment could be desegmented.
    /// A dissector that can offer this API (e.g.
    /// TCP) sets can_desegment=2, then
    /// can_desegment is decremented by 1 each time
    /// we pass to the next subdissector. Thus only
    /// the dissector immediately above the
    /// protocol which sets the flag can use it
    pub can_desegment: guint16,
    /// < Value of can_desegment before current
    /// dissector was called.  Supplied so that
    /// dissectors for proxy protocols such as
    /// SOCKS can restore it, allowing the
    /// dissectors that they call to use the
    /// TCP dissector's desegmentation (SOCKS
    /// just retransmits TCP segments once it's
    /// finished setting things up, so the TCP
    /// desegmentor can desegment its payload).
    pub saved_can_desegment: guint16,
    /// < offset to stuff needing desegmentation
    pub desegment_offset: ::std::os::raw::c_int,
    /// < requested desegmentation additional length
    /// or
    /// DESEGMENT_ONE_MORE_SEGMENT:
    /// Desegment one more full segment
    /// (warning! only partially implemented)
    /// DESEGMENT_UNTIL_FIN:
    /// Desgment all data for this tcp session
    /// until the FIN segment.
    pub desegment_len: guint32,
    /// < >0 if the subdissector has specified
    /// a value in 'bytes_until_next_pdu'.
    /// When a dissector detects that the next PDU
    /// will start beyond the start of the next
    /// segment, it can set this value to 2
    /// and 'bytes_until_next_pdu' to the number of
    /// bytes beyond the next segment where the
    /// next PDU starts.
    ///
    /// If the protocol dissector below this
    /// one is capable of PDU tracking it can
    /// use this hint to detect PDUs that starts
    /// unaligned to the segment boundaries.
    /// The TCP dissector is using this hint from
    /// (some) protocols to detect when a new PDU
    /// starts in the middle of a tcp segment.
    ///
    /// There is intelligence in the glue between
    /// dissector layers to make sure that this
    /// request is only passed down to the protocol
    /// immediately below the current one and not
    /// any further.
    pub want_pdu_tracking: guint16,
    pub bytes_until_next_pdu: guint32,
    /// < Packet was captured as an
    /// outbound (P2P_DIR_SENT)
    /// inbound (P2P_DIR_RECV)
    /// unknown (P2P_DIR_UNKNOWN)
    pub p2p_dir: ::std::os::raw::c_int,
    /// < a hash table passed from one dissector to another
    pub private_table: *mut GHashTable,
    /// < layers of each protocol
    pub layers: *mut wmem_list_t,
    /// < The current "depth" or layer number in the current frame
    pub curr_layer_num: guint8,
    pub link_number: guint16,
    /// < clnp/cotp source reference (can't use srcport, this would confuse tpkt)
    pub clnp_srcref: guint16,
    /// < clnp/cotp destination reference (can't use dstport, this would confuse tpkt)
    pub clnp_dstref: guint16,
    /// < 3GPP messages are sometime different UP link(UL) or Downlink(DL)
    pub link_dir: ::std::os::raw::c_int,
    /// < Per packet proto data
    pub proto_data: *mut GSList,
    /// < A list of frames which this one depends on
    pub dependent_frames: *mut GSList,
    pub frame_end_routines: *mut GSList,
    /// < Memory pool scoped to the pinfo struct
    pub pool: *mut wmem_allocator_t,
    pub epan: *mut epan_session,
    /// < name of heur list if this packet is being heuristically dissected
    pub heur_list_name: *const gchar,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _packet_info__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__packet_info__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_packet_info__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_packet_info__bindgen_ty_1))
    );
}
impl _packet_info__bindgen_ty_1 {
    #[inline]
    pub fn in_error_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_error_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_gre_pkt(&self) -> guint32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_gre_pkt(&mut self, val: guint32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_error_pkt: guint32,
        in_gre_pkt: guint32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_error_pkt: u32 = unsafe { ::std::mem::transmute(in_error_pkt) };
            in_error_pkt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_gre_pkt: u32 = unsafe { ::std::mem::transmute(in_gre_pkt) };
            in_gre_pkt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__packet_info() {
    assert_eq!(
        ::std::mem::size_of::<_packet_info>(),
        400usize,
        concat!("Size of: ", stringify!(_packet_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_packet_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_packet_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).current_proto as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(current_proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).cinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(cinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).presence_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(presence_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).abs_ts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(abs_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).rel_ts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(rel_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pkt_encap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pkt_encap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pseudo_header as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pseudo_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).phdr as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(phdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).data_src as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(data_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_src as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dl_dst as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dl_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_src as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).net_dst as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(net_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).src as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dst as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).vlan_id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(vlan_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).ctype as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ctype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).circuit_id as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(circuit_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).noreassembly_reason as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(noreassembly_reason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).fragmented as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(fragmented)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).flags as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).ptype as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(ptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).srcport as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(srcport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).destport as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(destport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_uint as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).match_string as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(match_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).can_desegment as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(can_desegment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).saved_can_desegment as *const _ as usize
        },
        298usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(saved_can_desegment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_offset as *const _ as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).desegment_len as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(desegment_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).want_pdu_tracking as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(want_pdu_tracking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_packet_info>())).bytes_until_next_pdu as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(bytes_until_next_pdu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).p2p_dir as *const _ as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(p2p_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).private_table as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(private_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).layers as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(layers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).curr_layer_num as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(curr_layer_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_number as *const _ as usize },
        338usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_srcref as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_srcref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).clnp_dstref as *const _ as usize },
        342usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(clnp_dstref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).link_dir as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(link_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).proto_data as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(proto_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).dependent_frames as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(dependent_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).frame_end_routines as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(frame_end_routines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).pool as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).epan as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(epan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_packet_info>())).heur_list_name as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_packet_info),
            "::",
            stringify!(heur_list_name)
        )
    );
}
pub type packet_info = _packet_info;
pub const FT_NONE: ftenum = 0;
pub const FT_PROTOCOL: ftenum = 1;
pub const FT_BOOLEAN: ftenum = 2;
pub const FT_CHAR: ftenum = 3;
pub const FT_UINT8: ftenum = 4;
pub const FT_UINT16: ftenum = 5;
pub const FT_UINT24: ftenum = 6;
pub const FT_UINT32: ftenum = 7;
pub const FT_UINT40: ftenum = 8;
pub const FT_UINT48: ftenum = 9;
pub const FT_UINT56: ftenum = 10;
pub const FT_UINT64: ftenum = 11;
pub const FT_INT8: ftenum = 12;
pub const FT_INT16: ftenum = 13;
pub const FT_INT24: ftenum = 14;
pub const FT_INT32: ftenum = 15;
pub const FT_INT40: ftenum = 16;
pub const FT_INT48: ftenum = 17;
pub const FT_INT56: ftenum = 18;
pub const FT_INT64: ftenum = 19;
pub const FT_IEEE_11073_SFLOAT: ftenum = 20;
pub const FT_IEEE_11073_FLOAT: ftenum = 21;
pub const FT_FLOAT: ftenum = 22;
pub const FT_DOUBLE: ftenum = 23;
pub const FT_ABSOLUTE_TIME: ftenum = 24;
pub const FT_RELATIVE_TIME: ftenum = 25;
pub const FT_STRING: ftenum = 26;
pub const FT_STRINGZ: ftenum = 27;
pub const FT_UINT_STRING: ftenum = 28;
pub const FT_ETHER: ftenum = 29;
pub const FT_BYTES: ftenum = 30;
pub const FT_UINT_BYTES: ftenum = 31;
pub const FT_IPv4: ftenum = 32;
pub const FT_IPv6: ftenum = 33;
pub const FT_IPXNET: ftenum = 34;
pub const FT_FRAMENUM: ftenum = 35;
pub const FT_PCRE: ftenum = 36;
pub const FT_GUID: ftenum = 37;
pub const FT_OID: ftenum = 38;
pub const FT_EUI64: ftenum = 39;
pub const FT_AX25: ftenum = 40;
pub const FT_VINES: ftenum = 41;
pub const FT_REL_OID: ftenum = 42;
pub const FT_SYSTEM_ID: ftenum = 43;
pub const FT_STRINGZPAD: ftenum = 44;
pub const FT_FCWWN: ftenum = 45;
pub const FT_NUM_TYPES: ftenum = 46;
pub type ftenum = u32;
pub const BASE_NONE: field_display_e = 0;
pub const BASE_DEC: field_display_e = 1;
pub const BASE_HEX: field_display_e = 2;
pub const BASE_OCT: field_display_e = 3;
pub const BASE_DEC_HEX: field_display_e = 4;
pub const BASE_HEX_DEC: field_display_e = 5;
pub const BASE_CUSTOM: field_display_e = 6;
pub const BASE_FLOAT: field_display_e = 0;
pub const STR_ASCII: field_display_e = 0;
pub const STR_UNICODE: field_display_e = 7;
pub const SEP_DOT: field_display_e = 8;
pub const SEP_DASH: field_display_e = 9;
pub const SEP_COLON: field_display_e = 10;
pub const SEP_SPACE: field_display_e = 11;
pub const BASE_NETMASK: field_display_e = 12;
pub const BASE_PT_UDP: field_display_e = 13;
pub const BASE_PT_TCP: field_display_e = 14;
pub const BASE_PT_DCCP: field_display_e = 15;
pub const BASE_PT_SCTP: field_display_e = 16;
pub type field_display_e = u32;
pub const HF_REF_TYPE_NONE: hf_ref_type = 0;
pub const HF_REF_TYPE_INDIRECT: hf_ref_type = 1;
pub const HF_REF_TYPE_DIRECT: hf_ref_type = 2;
pub type hf_ref_type = u32;
/// information describing a header field
pub type header_field_info = _header_field_info;
/// information describing a header field
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _header_field_info {
    /// < [FIELDNAME] full name of this field
    pub name: *const ::std::os::raw::c_char,
    /// < [FIELDABBREV] abbreviated name of this field
    pub abbrev: *const ::std::os::raw::c_char,
    /// < [FIELDTYPE] field type, one of FT_ (from ftypes.h)
    pub type_: ftenum,
    /// < [FIELDDISPLAY] one of BASE_, or field bit-width if FT_BOOLEAN and non-zero bitmask
    pub display: ::std::os::raw::c_int,
    /// < [FIELDCONVERT] value_string, val64_string, range_string or true_false_string,
    /// typically converted by VALS(), RVALS() or TFS().
    /// If this is an FT_PROTOCOL or BASE_PROTOCOL_INFO then it points to the
    /// associated protocol_t structure
    pub strings: *const ::std::os::raw::c_void,
    /// < [BITMASK] bitmask of interesting bits
    pub bitmask: guint64,
    /// < [FIELDDESCR] Brief description of field
    pub blurb: *const ::std::os::raw::c_char,
    /// < Field ID
    pub id: ::std::os::raw::c_int,
    /// < parent protocol tree
    pub parent: ::std::os::raw::c_int,
    /// < is this field referenced by a filter
    pub ref_type: hf_ref_type,
    /// < ID of previous hfinfo with same abbrev
    pub same_name_prev_id: ::std::os::raw::c_int,
    /// < Link to next hfinfo with same abbrev
    pub same_name_next: *mut header_field_info,
}
#[test]
fn bindgen_test_layout__header_field_info() {
    assert_eq!(
        ::std::mem::size_of::<_header_field_info>(),
        72usize,
        concat!("Size of: ", stringify!(_header_field_info))
    );
    assert_eq!(
        ::std::mem::align_of::<_header_field_info>(),
        8usize,
        concat!("Alignment of ", stringify!(_header_field_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).abbrev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(abbrev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).display as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).strings as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).bitmask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(bitmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).blurb as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).parent as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_header_field_info>())).ref_type as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(ref_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_prev_id as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_prev_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_header_field_info>())).same_name_next as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_header_field_info),
            "::",
            stringify!(same_name_next)
        )
    );
}
/// Used when registering many fields at once, using proto_register_field_array()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hf_register_info {
    /// < written to by register() function
    pub p_id: *mut ::std::os::raw::c_int,
    /// < the field info to be registered
    pub hfinfo: header_field_info,
}
#[test]
fn bindgen_test_layout_hf_register_info() {
    assert_eq!(
        ::std::mem::size_of::<hf_register_info>(),
        80usize,
        concat!("Size of: ", stringify!(hf_register_info))
    );
    assert_eq!(
        ::std::mem::align_of::<hf_register_info>(),
        8usize,
        concat!("Alignment of ", stringify!(hf_register_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).p_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(p_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<hf_register_info>())).hfinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hf_register_info),
            "::",
            stringify!(hfinfo)
        )
    );
}
/// A protocol tree element.
pub type proto_tree = [u64; 6usize];
/// A protocol item element.
pub type proto_item = [u64; 6usize];
extern "C" {

    /// Create a subtree under an existing item.
    /// @param ti the parent item of the new subtree
    /// @param idx one of the ett_ array elements registered with proto_register_subtree_array()
    /// @return the new subtree
    pub fn proto_item_add_subtree(ti: *mut proto_item, idx: gint) -> *mut proto_tree;
}
extern "C" {
    pub fn proto_tree_add_item(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        encoding: guint,
    ) -> *mut proto_item;
}
extern "C" {

    /// Add a formatted FT_STRING or FT_STRINGZPAD to a proto_tree, with the
    /// format generating the entire string for the entry, including any field
    /// name.
    /// @param tree the tree to append this item to
    /// @param hfindex field index
    /// @param tvb the tv buffer of the current data
    /// @param start start of data in tvb
    /// @param length length of data in tvb
    /// @param value data to display
    /// @param format printf like format string
    /// @param ... printf like parameters
    /// @return the newly created item
    pub fn proto_tree_add_string_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {

    /// Add a formatted FT_BOOLEAN to a proto_tree, with the format generating
    /// the entire string for the entry, including any field name.
    /// @param tree the tree to append this item to
    /// @param hfindex field index
    /// @param tvb the tv buffer of the current data
    /// @param start start of data in tvb
    /// @param length length of data in tvb
    /// @param value data to display
    /// @param format printf like format string
    /// @param ... printf like parameters
    /// @return the newly created item
    pub fn proto_tree_add_boolean_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {

    /// Add a formatted FT_UINT8, FT_UINT16, FT_UINT24 or FT_UINT32 to a proto_tree,
    /// with the format generating the entire string for the entry, including any
    /// field name.
    /// @param tree the tree to append this item to
    /// @param hfindex field index
    /// @param tvb the tv buffer of the current data
    /// @param start start of data in tvb
    /// @param length length of data in tvb
    /// @param value data to display
    /// @param format printf like format string
    /// @param ... printf like parameters
    /// @return the newly created item
    pub fn proto_tree_add_uint_format(
        tree: *mut proto_tree,
        hfindex: ::std::os::raw::c_int,
        tvb: *mut tvbuff_t,
        start: gint,
        length: gint,
        value: guint32,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut proto_item;
}
extern "C" {

    /// Register a new protocol.
    /// @param name the full name of the new protocol
    /// @param short_name abbreviated name of the new protocol
    /// @param filter_name protocol name used for a display filter string
    /// @return the new protocol handle
    pub fn proto_register_protocol(
        name: *const ::std::os::raw::c_char,
        short_name: *const ::std::os::raw::c_char,
        filter_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {

    /// Register a header_field array.
    /// @param parent the protocol handle from proto_register_protocol()
    /// @param hf the hf_register_info array
    /// @param num_records the number of records in hf
    pub fn proto_register_field_array(
        parent: ::std::os::raw::c_int,
        hf: *mut hf_register_info,
        num_records: ::std::os::raw::c_int,
    );
}
extern "C" {

    /// Register a protocol subtree (ett) array.
    /// @param indices array of ett indices
    /// @param num_indices the number of records in indices
    pub fn proto_register_subtree_array(
        indices: *const *const gint,
        num_indices: ::std::os::raw::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epan_column_info {
    _unused: [u8; 0],
}
pub type column_info = epan_column_info;
pub const COL_8021Q_VLAN_ID: _bindgen_ty_21 = 0;
pub const COL_ABS_YMD_TIME: _bindgen_ty_21 = 1;
pub const COL_ABS_YDOY_TIME: _bindgen_ty_21 = 2;
pub const COL_ABS_TIME: _bindgen_ty_21 = 3;
pub const COL_VSAN: _bindgen_ty_21 = 4;
pub const COL_CUMULATIVE_BYTES: _bindgen_ty_21 = 5;
pub const COL_CUSTOM: _bindgen_ty_21 = 6;
pub const COL_DCE_CALL: _bindgen_ty_21 = 7;
pub const COL_DELTA_TIME: _bindgen_ty_21 = 8;
pub const COL_DELTA_TIME_DIS: _bindgen_ty_21 = 9;
pub const COL_RES_DST: _bindgen_ty_21 = 10;
pub const COL_UNRES_DST: _bindgen_ty_21 = 11;
pub const COL_RES_DST_PORT: _bindgen_ty_21 = 12;
pub const COL_UNRES_DST_PORT: _bindgen_ty_21 = 13;
pub const COL_DEF_DST: _bindgen_ty_21 = 14;
pub const COL_DEF_DST_PORT: _bindgen_ty_21 = 15;
pub const COL_EXPERT: _bindgen_ty_21 = 16;
pub const COL_IF_DIR: _bindgen_ty_21 = 17;
pub const COL_FREQ_CHAN: _bindgen_ty_21 = 18;
pub const COL_DEF_DL_DST: _bindgen_ty_21 = 19;
pub const COL_DEF_DL_SRC: _bindgen_ty_21 = 20;
pub const COL_RES_DL_DST: _bindgen_ty_21 = 21;
pub const COL_UNRES_DL_DST: _bindgen_ty_21 = 22;
pub const COL_RES_DL_SRC: _bindgen_ty_21 = 23;
pub const COL_UNRES_DL_SRC: _bindgen_ty_21 = 24;
pub const COL_RSSI: _bindgen_ty_21 = 25;
pub const COL_TX_RATE: _bindgen_ty_21 = 26;
pub const COL_DSCP_VALUE: _bindgen_ty_21 = 27;
pub const COL_INFO: _bindgen_ty_21 = 28;
pub const COL_RES_NET_DST: _bindgen_ty_21 = 29;
pub const COL_UNRES_NET_DST: _bindgen_ty_21 = 30;
pub const COL_RES_NET_SRC: _bindgen_ty_21 = 31;
pub const COL_UNRES_NET_SRC: _bindgen_ty_21 = 32;
pub const COL_DEF_NET_DST: _bindgen_ty_21 = 33;
pub const COL_DEF_NET_SRC: _bindgen_ty_21 = 34;
pub const COL_NUMBER: _bindgen_ty_21 = 35;
pub const COL_PACKET_LENGTH: _bindgen_ty_21 = 36;
pub const COL_PROTOCOL: _bindgen_ty_21 = 37;
pub const COL_REL_TIME: _bindgen_ty_21 = 38;
pub const COL_DEF_SRC: _bindgen_ty_21 = 39;
pub const COL_DEF_SRC_PORT: _bindgen_ty_21 = 40;
pub const COL_RES_SRC: _bindgen_ty_21 = 41;
pub const COL_UNRES_SRC: _bindgen_ty_21 = 42;
pub const COL_RES_SRC_PORT: _bindgen_ty_21 = 43;
pub const COL_UNRES_SRC_PORT: _bindgen_ty_21 = 44;
pub const COL_TEI: _bindgen_ty_21 = 45;
pub const COL_UTC_YMD_TIME: _bindgen_ty_21 = 46;
pub const COL_UTC_YDOY_TIME: _bindgen_ty_21 = 47;
pub const COL_UTC_TIME: _bindgen_ty_21 = 48;
pub const COL_CLS_TIME: _bindgen_ty_21 = 49;
pub const NUM_COL_FMTS: _bindgen_ty_21 = 50;
pub type _bindgen_ty_21 = u32;
extern "C" {

    /// Clears the text of a column element.
    ///
    /// @param cinfo the current packet row
    /// @param col the column to use, e.g. COL_INFO
    pub fn col_clear(cinfo: *mut column_info, col: gint);
}
extern "C" {

    /// Set (replace) the text of a column element, the text won't be copied.
    ///
    /// Usually used to set const strings!
    ///
    /// @param cinfo the current packet row
    /// @param col the column to use, e.g. COL_INFO
    /// @param str the string to set
    pub fn col_set_str(cinfo: *mut column_info, col: gint, str: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dissector_handle {
    _unused: [u8; 0],
}
pub type dissector_handle_t = *mut dissector_handle;
pub type dissector_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut tvbuff_t,
        arg2: *mut packet_info,
        arg3: *mut proto_tree,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn dissector_add_uint(
        name: *const ::std::os::raw::c_char,
        pattern: guint32,
        handle: dissector_handle_t,
    );
}
extern "C" {

    /// Create an anonymous handle for a dissector.
    pub fn create_dissector_handle(
        dissector: dissector_t,
        proto: ::std::os::raw::c_int,
    ) -> dissector_handle_t;
}
extern "C" {
    pub fn add_new_data_source(
        pinfo: *mut packet_info,
        tvb: *mut tvbuff_t,
        name: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
pub union wtap_pseudo_header {
    pub _bindgen_opaque_blob: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_wtap_pseudo_header() {
    assert_eq!(
        ::std::mem::size_of::<wtap_pseudo_header>(),
        0usize,
        concat!("Size of: ", stringify!(wtap_pseudo_header))
    );
    assert_eq!(
        ::std::mem::align_of::<wtap_pseudo_header>(),
        0usize,
        concat!("Alignment of ", stringify!(wtap_pseudo_header))
    );
}
